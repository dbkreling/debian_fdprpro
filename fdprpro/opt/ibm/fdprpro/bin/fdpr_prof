#!/bin/sh
# performs FDPR profiling
# invocation: fdpr_prof <prog> <arg> ...
# environment:
# FDPR_LIBDIR - directory containing fdpr instrumentation libraries
# FDPR_SONAME - if present, the shared library to process
# FDPR_PROF_COMMAND -if present, actual profiling script
# FDPR_CONT_PROGRAM - if equal to 1, continue the running program
# FDPR_PROF_DURATION - if equal to integer >0, profile for that amount of time. 
#     Otherwise, profile until completion
# FDPR_CONT_PROFILING - if equal to 1, continue with profile from last session.
#     Otherwise, restart with empty profile                  
# input:
# <prog>.instr - instrumented program
# <prog>.prof - profile template
# <arg> ... - execution arguments
# output:
# <prog>.prof - filled profile
# returns:
# status of profiled run

# send signal to whole process tree
send_ptree() {
    local _pid=$2
    if [ "$_pid" = "" ]; then return; fi
    local _sig=${1-TERM}
    kill -stop ${_pid} 2>/dev/null # needed to stop quickly forking parent from producing child between child killing and parent killing
    for _child in $(ps -o pid --no-headers --ppid ${_pid}); do
        send_ptree ${_sig} ${_child}
    done
    kill -${_sig} ${_pid} 2>/dev/null
}
# get pid given program name
get_pid() {
    local prog="$1"
    pgrep -U $USER "^$prog\$"
}
get_pidn() {
    local prog="$1"
    pgrep -n -U $USER "^$prog\$"
}
FDPR_HIDDEN=$HOME/.fdpr
mkdir -p $FDPR_HIDDEN

in=$1
shift
args=$*
if [ "$FDPR_LIBDIR" = "" ]; then FDPR_LIBDIR=/opt/ibm/fdprpro/lib; fi
export LD_LIBRARY_PATH=$FDPR_LIBDIR:$LD_LIBRARY_PATH

# determine executable
prof="$in".prof
saved_prof=$FDPR_HIDDEN/`basename "$in"`.prof
if [ "$FDPR_SONAME" != "" ]; then 
    soname_orig=$FDPR_HIDDEN/`basename "$FDPR_SONAME"`.orig
    prof="$FDPR_SONAME".prof
    saved_prof=$FDPR_HIDDEN/`basename "$FDPR_SONAME"`.prof
    # profiling a shared library:replace original library by instrumented version
    if [ ! -r $FDPR_SONAME ]; then echo "fdpr_prof: non-existent shared library: $FDPR_SONAME"; exit 1; fi
    if [ ! -r $FDPR_SONAME.instr ]; then echo "fdpr_prof: missing instrumented shared library: $FDPR_SONAME.instr"; exit 1; fi
    cp -p "$FDPR_SONAME" "$soname_orig"
    cp -p "$FDPR_SONAME.instr" "$FDPR_SONAME"
    dirname=`dirname "$FDPR_SONAME"`
    export LD_LIBRARY_PATH=$dirname:$LD_LIBRARY_PATH
    exec="$in"
else
    exec="$in".instr
fi
if [ ! -r "$exec" ]; then echo "fdpr_prof: non-existent input program: $exec"; exit 1; fi

# determine start profile
start_prof="$prof"
if [ -r "$saved_prof" -a "$FDPR_CONT_PROFILING" = "1" ]; then
    start_prof="$saved_prof"
else
    if [ -r "$saved_prof" ]; then
        start_prof="$saved_prof".orig
    fi
fi

# identify the program to be profiled
if [ "$FDPR_PROF_COMMAND" = "" ]; then
    prog="$exec"
else
    prog="$FDPR_PROF_COMMAND"
fi

# start/continue execution
saved_pid=$FDPR_HIDDEN/instr.pid
if [ "$FDPR_CONT_PROGRAM" != "1" ]; then
    # kill program if still running
    prev_pid=`cat "$saved_pid" 2>/dev/null`
    for ppid in $prev_pid `get_pid "^$prog\$"`; do
        echo killing ptree $ppid
        send_ptree KILL $ppid
    done
    cp -p "$start_prof" "$prof"
    # start program
    echo "FDPR profiling: $prog $args ..."
    # run program in background and save its PID
    "$prog" $args &
    prog_pid=`get_pidn "$prog"`
    echo $prog_pid > "$saved_pid"
else 
    # continue profiling a running program but make sure we have its pid
    prog_pid=`cat "$saved_pid"`
    if [ "$prog_pid" = "" ]; then
        prog_pid=`get_pidn "$prog"`
    fi
    ps -p $prog_pid > /dev/null 2>&1
    if [ $? != 0 ]; then
        echo "fdpr_prof: Profiled program $prog not found"
        exit 1
    fi
    # setup profile
    send_ptree STOP $prog_pid # setup profile 
    cp -p "$start_prof" "$prof"
    send_ptree CONT $prog_pid
fi
echo $prog_pid > "$saved_pid"

# wait for profiling period to complete
if [ "$FDPR_PROF_DURATION" != "" -a  "$FDPR_PROF_DURATION" != "0" ]; then
    echo "FDPR profiling: waiting for $FDPR_PROF_DURATION seconds"
    sleep $FDPR_PROF_DURATION
    stat=$?
    # pause program to allow capturing profile
    send_ptree STOP $prog_pid
else
    # wait for program to complete
    if [ "$FDPR_CONT_PROGRAM" != "1" ]; then
        wait $prog_pid
    else
        # program was not initiated by this shell
        echo "FDPR profiling: waiting for "$prog" to complete"
        while ( kill -0 $prog_pid 2>/dev/null ); do
            sleep 1 # wait for someone to kill it
        done
    fi
    stat=$?
    rm -f "$saved_pid"
fi
# save profile for later processing
cp -p "$prof" "$saved_prof"
send_ptree CONT $prog_pid  # in case program is still running

if [ "$FDPR_SONAME" != "" ]; then 
    # reset shared library to its original version
    cp -p "$soname_orig" "$FDPR_SONAME"
    rm  "$soname_orig"
fi
if [ "$stat" != "0" ]; then
    echo "FDPR profiling: terminated with code $stat"
fi
# check if profile was filled
empty=`(od -Ax -tx4 "$saved_prof" | head -4 | tail -1 |awk '{ print $4 }') 2>/dev/null`
if [ "$empty" = "00000000" ]; then 
    exit 0 # profile is not empty
else
    exit 1
fi
exit $stat
